# 가장 큰 수
# 문제 설명
# 0 또는 양의 정수가 주어졌을 때,
# 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.
#
# 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고,
# 이중 가장 큰 수는 6210입니다.
#
# 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때,
# 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.
#
# 제한 사항
# numbers의 길이는 1 이상 100,000 이하입니다.
# numbers의 원소는 0 이상 1,000 이하입니다.
# 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.

# 입출력 예
# numbers	            return
# [6, 10, 2]	        "6210"
# [3, 30, 34, 5, 9]     "9534330"

def solution(numbers):
    # [0, 0, 0] 일 때 예외처리 추가
    if sum(numbers) == 0:
        return '0'

    # 값이 최대 1000이기 때문에 최소 한자리의 숫자를 문자열 * 3으로 해주어 3자리로 늘려 값 비교를 한다.
    # ex> 3, 30, 34 >>> x * 3 >>> 333, 303030, 343434
    #     위의 333, 303030, 343434를 비교했을 때 343434 > 333 > 303030으로 결과를 얻을 수 있다.
    all = sorted(map(str, numbers), key=lambda x: x * 3, reverse=True)
    # sum은 int 값만 가능한가범...
    return "".join(all)

# 줄이면 이렇게까지도 가능한데... 한눈에 못알아보면 의미가 있나
# def solution(numbers):
#     # [0, 0, 0] 일 때 예외처리 추가
#     if sum(numbers) == 0:
#         return '0'
#
#     return "".join(sorted(map(str, numbers), key=lambda x: x * 3, reverse=True))

# 정확성  테스트
# 테스트 1 〉	통과 (39.10ms, 23.2MB)
# 테스트 2 〉	통과 (21.05ms, 17.1MB)
# 테스트 3 〉	통과 (52.92ms, 27.4MB)
# 테스트 4 〉	통과 (1.44ms, 10.4MB)
# 테스트 5 〉	통과 (34.52ms, 21.8MB)
# 테스트 6 〉	통과 (30.09ms, 20.3MB)
# 테스트 7 〉	통과 (0.02ms, 10.2MB)
# 테스트 8 〉	통과 (0.01ms, 10.2MB)
# 테스트 9 〉	통과 (0.01ms, 10.2MB)
# 테스트 10 〉	통과 (0.01ms, 10.3MB)
# 테스트 11 〉	통과 (0.00ms, 10.2MB)

# [0, 0, 0] 일 때 예외처리를 sum이 아닌 str(int(~~~))로 했을 때 시간
# 정확성  테스트
# 테스트 1 〉	통과 (788.99ms, 23.3MB)
# 테스트 2 〉	통과 (229.06ms, 17.2MB)
# 테스트 3 〉	통과 (1267.17ms, 27.4MB)
# 테스트 4 〉	통과 (2.02ms, 10.5MB)
# 테스트 5 〉	통과 (590.72ms, 21.8MB)
# 테스트 6 〉	통과 (453.02ms, 20.3MB)
# 테스트 7 〉	통과 (0.03ms, 10.3MB)
# 테스트 8 〉	통과 (0.03ms, 10.4MB)
# 테스트 9 〉	통과 (0.03ms, 10.4MB)
# 테스트 10 〉	통과 (0.03ms, 10.4MB)
# 테스트 11 〉	통과 (0.04ms, 10.4MB)

print(solution([6, 10, 2]))
print(solution([3, 30, 34, 5, 9]))
print(solution([0, 0, 0]))